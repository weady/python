#!/usr/bin/python
#coding:utf8

#	by wangdd 2016/11/07
#这个文件主要记录学习pythoncookbook书时的学习笔记

#--------------------第一章----------------------------------
	collections.deque 双向队列,deque(maxlen=N)构造一个固定大小的队列,当新的元素加入并且这个队列已满的时候
	最老的元素会自动被移除掉
	q = deque(maxlen=3)
	q.append(1)
	如果你不设置最大队列大小那么就会得到一个无限大小队列你可以在队列的两端执行添加和弹出元素的操作
	q = deque()
	q.appendleft(4)	#队列左侧添加数据
	q.popleft()	#提出队列最左侧数据

	从一个集合中获取最大或最小的N个元素列表heapq 模块 nlargest() nsmallest()
	heap(0) 永远是最小的元素,并且剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到
	该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素
	获取唯一一个最大或最小的 使用min() max() 即可
	如果N的大小和集合大小接近的时候 通常先排序这个集合然后再使用切片操作会更快点 
	( sorted(items)[:N] 或者是 sorted(items)[-N:] )

	s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
	d = collections.defaultdict(list)
	for k, v in s:
    	d[k].append(v)
    
    使用 collections 模块中的 OrderedDict 类。 在迭代操作的时候它会保持元素被插入时的顺序
    在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值
    获取字典中的最大值或最小值,利用zip() 对k,v进行反转然后利用max() 比较key 即可
    查找两个字典的相同点 可以使用集合操作的方式 & - ^
    a.keys() & b.keys() 发现字典a,b中的相同key
    a.keys() - b.keys() 发现在a中不在b中
    a.keys() ^ b.keys() 发现字典a,b 中的不同key
    a.items() & b.items() 发现字典中的相同(key,value)


#--------------------第二章----------------------------------
#--------------------第三章----------------------------------
#--------------------第四章----------------------------------
#--------------------第五章----------------------------------
#--------------------第六章----------------------------------
#--------------------第七章----------------------------------
#--------------------第八章----------------------------------
#--------------------第九章----------------------------------
#--------------------第十章----------------------------------
#--------------------第十一章----------------------------------
#--------------------第十二章 并发编程----------------------------------
'''
Python解释器直到所有线程都终止前仍保持运行
对于需要长时间运行的线程或者需要一直运行的后台任务你应当考虑使用后台线程
由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型
所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等
而不是需要多处理器并行的计算密集型任务
'''
from threading import Thread
t = Thread(target=countdown, args=(10,))
t.start() #启动线程
if t.is_alive(): #查看一个线程的状态
    print('Still running')
else:
        print('Completed')
t = Thread(target=countdown, args=(10,), daemon=True) #设定守护线程
t.start()
